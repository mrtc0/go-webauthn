package webauthn

import "fmt"

type Session struct {
	// ID is a unique identifier for the session.
	ID []byte
	// Challenge is a non-guessable value to prevent reply attacks.
	// MUST be randomly generated by Relying Parties in an environment they trust (e.g., on the server-side),
	// and the returned challenge value in the clientâ€™s response MUST match what was generated.
	// In order to prevent replay attacks, the challenges MUST contain enough entropy to
	// make guessing them infeasible. Challenges SHOULD therefore be at least 16 bytes long.
	Challenge []byte
	// RPID is the Relying Party identifier.
	RPID string
	// UserVerification is the user verification requirement.
	// valid values are "required", "preferred", "discouraged"
	UserVerification UserVerification

	// AllowedCredentials is an OPTIONAL member,
	// used by the client to find qualified authenticators for this authentication ceremony.
	// If the user account is identified during authentication,
	// the credentials of the user account should be listed for this member.
	// more details: https://www.w3.org/TR/webauthn-3/#dom-publickeycredentialrequestoptions-allowcredentials
	AllowedCredentials []PublicKeyCredentialDescriptor
}

func NewWebAuthnSession(id, challenge []byte, rpid string, userVerification UserVerification, allowedCredentials []PublicKeyCredentialDescriptor) (*Session, error) {
	if !validUserVerification(userVerification) {
		return nil, fmt.Errorf("invalid user verification: %s, valid values are 'required', 'preferred', 'discouraged'", userVerification)
	}

	if !IsValidChallenge(challenge) {
		return nil, fmt.Errorf("challenge is too short, expected at least 16 bytes")
	}

	return &Session{
		ID:                 id,
		Challenge:          challenge,
		RPID:               rpid,
		UserVerification:   userVerification,
		AllowedCredentials: allowedCredentials,
	}, nil
}

func validUserVerification(userVerification UserVerification) bool {
	if userVerification == "required" || userVerification == "preferred" || userVerification == "discouraged" {
		return true
	}

	return false
}
